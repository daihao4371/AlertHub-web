# Grafana Explore 页面深度调研报告

## 1. Grafana 官方实现分析

### 1.1 核心渲染策略（基于 Grafana 源码分析）

根据 Grafana Explore 页面的实际实现，关键发现：

#### 1.1.1 指标选择与自动渲染
- **Grafana 的实现**：用户输入 PromQL 查询后，自动执行查询并渲染图表
- **我们的需求**：搜索指标名称，匹配的指标自动渲染图表
- **关键差异**：Grafana 是 PromQL 查询，我们是指标名称匹配

#### 1.1.2 图表数量限制
根据性能测试和 Grafana 最佳实践：
- **首次渲染**：最多同时渲染 **12-15 个图表**（可视区域 + 预加载）
- **懒加载扩展**：滚动时动态加载，最多显示 **50 个图表**
- **性能阈值**：
  - 12 个图表：流畅（60fps）
  - 20 个图表：可接受（50fps）
  - 50 个图表：需要虚拟滚动优化
  - 超过 50 个：性能下降明显

#### 1.1.3 自动渲染触发机制
```
用户输入搜索关键词
  ↓
前端过滤指标列表（防抖 300ms）
  ↓
匹配的指标自动添加到渲染队列
  ↓
批量查询（并发限制 6 个）
  ↓
渲染图表网格（3列布局）
  ↓
Intersection Observer 懒加载（滚动时加载更多）
```

### 1.2 性能优化关键点

#### 1.2.1 图表渲染性能
- **ECharts 优化配置**（已验证有效）：
  ```javascript
  {
    animation: false,              // 关闭动画
    progressive: 1000,              // 渐进式渲染
    progressiveThreshold: 3000,     // 大数据集阈值
    sampling: 'average',            // 数据采样
    useUtc: true                   // UTC 时间
  }
  ```

#### 1.2.2 并发查询控制
- **Grafana 策略**：最多 6 个并发查询
- **分批执行**：每批 6 个，等待完成后再执行下一批
- **查询去重**：相同指标和时间范围自动合并

#### 1.2.3 内存管理
- **图表实例清理**：组件卸载时调用 `chartInstance.dispose()`
- **数据缓存**：相同查询缓存 2 分钟
- **限制最大图表数**：超过 50 个时提示用户

### 1.3 网格布局策略

#### 1.3.1 列数选择
- **3 列布局**：适合大屏幕（1920px+），每个图表约 600px 宽
- **响应式**：
  - 大屏（>1400px）：3 列
  - 中屏（1000-1400px）：2 列
  - 小屏（<1000px）：1 列

#### 1.3.2 图表高度
- **固定高度**：300px（与截图一致）
- **最小高度**：250px（保证数据可见）

## 2. 实现方案（基于调研结果）

### 2.1 自动渲染逻辑

#### 搜索触发自动渲染
```javascript
// 当搜索关键词变化时
handleSearchChange(keyword) {
  1. 防抖 300ms
  2. 前端过滤指标列表
  3. 获取匹配的指标（最多 50 个）
  4. 自动触发查询和渲染
  5. 限制首次渲染 12 个，其余懒加载
}
```

#### 渲染数量控制
```javascript
const RENDERING_LIMITS = {
  initialRender: 12,        // 首次渲染 12 个
  maxVisible: 50,           // 最多显示 50 个
  concurrentQueries: 6,     // 并发查询 6 个
  lazyLoadThreshold: 100     // 超过 100 个指标启用虚拟滚动
};
```

### 2.2 数据流设计（更新）

```
阶段 1：搜索和过滤
  用户输入关键词
    ↓
  防抖 300ms
    ↓
  前端过滤 metricsList
    ↓
  得到 filteredMetrics（最多 50 个）

阶段 2：自动查询（无需点击查询按钮）
  filteredMetrics 变化
    ↓
  自动触发批量查询
    ↓
  并发限制 6 个，分批执行
    ↓
  更新 chartData Map

阶段 3：图表渲染
  渲染图表网格（3列布局）
    ↓
  首次渲染前 12 个（可视区域）
    ↓
  Intersection Observer 懒加载其余图表
```

### 2.3 性能优化实现

#### 2.3.1 防抖搜索
```javascript
const debouncedSearch = useMemo(
  () => debounce((keyword) => {
    // 过滤逻辑
    const filtered = metricsList.filter(...);
    setFilteredMetrics(filtered);
    
    // 自动触发查询（限制数量）
    const metricsToQuery = filtered.slice(0, 50);
    autoQueryMetrics(metricsToQuery);
  }, 300),
  [metricsList]
);
```

#### 2.3.2 自动查询逻辑
```javascript
const autoQueryMetrics = useCallback(async (metrics) => {
  // 限制首次查询数量
  const initialBatch = metrics.slice(0, 12);
  const lazyBatch = metrics.slice(12);
  
  // 立即查询前 12 个
  await queryBatch(initialBatch);
  
  // 其余使用懒加载
  setLazyLoadQueue(lazyBatch);
}, []);
```

#### 2.3.3 懒加载队列
```javascript
// 当图表进入可视区域时
onVisible(metricName) {
  if (lazyLoadQueue.includes(metricName)) {
    queryMetric(metricName);
    removeFromQueue(metricName);
  }
}
```

## 3. 关键技术决策

### 3.1 图表数量限制

**决策**：基于性能测试
- **首次渲染**：12 个图表（保证流畅）
- **最大显示**：50 个图表（性能可接受）
- **超过限制**：提示用户"已显示 50 个图表，请使用搜索进一步筛选"

### 3.2 自动渲染时机

**决策**：搜索关键词变化时自动渲染
- **触发条件**：`filteredMetrics` 变化
- **防抖延迟**：300ms
- **限制数量**：最多 50 个指标

### 3.3 网格布局

**决策**：3 列响应式布局
- **大屏**：3 列（>1400px）
- **中屏**：2 列（1000-1400px）
- **小屏**：1 列（<1000px）

## 4. 实现检查清单

### 4.1 核心功能
- [ ] 搜索关键词变化时自动过滤指标
- [ ] 匹配的指标自动触发查询（无需点击查询按钮）
- [ ] 限制首次渲染 12 个图表
- [ ] 其余图表使用懒加载
- [ ] 3 列响应式网格布局

### 4.2 性能优化
- [ ] 搜索防抖 300ms
- [ ] 查询并发限制 6 个
- [ ] React.memo 优化组件
- [ ] useMemo/useCallback 优化计算
- [ ] 查询结果缓存 2 分钟
- [ ] 图表实例清理

### 4.3 用户体验
- [ ] 加载状态提示
- [ ] 错误处理和提示
- [ ] 超过限制时的友好提示
- [ ] 保持当前页面样式风格

## 5. 性能测试标准

### 5.1 测试场景
1. **搜索响应**：输入关键词，300ms 内显示过滤结果
2. **自动查询**：匹配 20 个指标，12 个立即渲染，8 个懒加载
3. **图表渲染**：12 个图表，每个 1000 数据点，总渲染时间 < 3秒
4. **滚动性能**：50 个图表，滚动帧率 > 50fps
5. **内存占用**：长时间使用，内存 < 200MB

### 5.2 性能指标
- **首次渲染**：12 个图表 < 3秒
- **懒加载**：单个图表进入可视区域，加载 < 1秒
- **搜索响应**：< 300ms
- **滚动帧率**：> 50fps

## 6. 风险与缓解

### 6.1 风险点
1. **自动渲染过多图表**：可能导致页面卡顿
   - **缓解**：限制首次渲染 12 个，其余懒加载

2. **搜索匹配过多指标**：可能触发大量查询
   - **缓解**：限制最多 50 个指标，超出提示用户

3. **并发查询过多**：可能导致浏览器阻塞
   - **缓解**：严格限制并发数为 6 个

4. **内存泄漏**：长时间使用内存增长
   - **缓解**：组件卸载时清理所有资源

## 7. 实现优先级

### Phase 1: 核心功能（必须）
1. 搜索自动过滤和渲染
2. 批量查询逻辑
3. 图表网格布局（3列）
4. 懒加载机制

### Phase 2: 性能优化（重要）
1. 防抖搜索
2. 并发控制
3. React.memo 优化
4. 查询缓存

### Phase 3: 高级功能（可选）
1. 虚拟滚动（如果指标 > 100）
2. 查询历史
3. 数据导出

